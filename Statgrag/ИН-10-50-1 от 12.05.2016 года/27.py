"""
В декартовой системе задано определённое множество точек.
Никакие три из них не лежат на одной прямой, никакие две не совпадают.
Надо найти количество треугольников обладающий свойствами
1) Все вершины из заданого множества.
2) Ни одна из вершин не лежит на осях.
3) Полученый треугольник должен пересекать ОХ, но не пересекать ОУ.
Необходимо чтобы программа работала за O(n) по времени, O(1) по памяти(не больше килобайта).

В первой строке - количество точек в множестве(n).
Каждая следующая из n строк содежит координаты точки(x,y).
1<=n<=10000, x и y не превосходят по модулю тысячу.
Пример:
4
6 6
-8 8
-9 -9
-7 5
Программа должна вывести макимальное количество треугольников:
1
"""


def fact(a):  # Вычисление факториала заданного числа
    sm = 1
    for g in range(1, a+1):
        sm *= g
    return sm


def C(n, k):  # функция вычисляет число сочетаний из k по n
    return fact(k)//(fact(k-n)*fact(n))


n = int(input())
is_one = 0  # количество точек в 1 четверти
is_two = 0  # количество точек во 2 четверти
is_three = 0
is_four = 0
s = 0
for k in range(n):
    x, y = map(int, input().split())
    if y == 0 or x == 0:  # фильтруем элементы по четвертям
        continue
    elif x > 0:
        if y > 0:
            is_one += 1
        else:
            is_four += 1
    else:
        if y > 0:
            is_two += 1
        else:
            is_three += 1
if is_four > 0 and is_one > 0:  # вычисляем число способов для 1 и 4
    s += C(2, is_four)*is_one
    s += C(2, is_one)*is_four
if is_two > 0 and is_three > 0:  # вычисляем число способов для 2 и 3
    s += C(2, is_two)*is_three
    s += C(2, is_three)*is_two
print(s)
